{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "78e7f882_dfae6c6c",
        "filename": "media/libaudioclient/include/media/TrackPlayerBase.h",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 1003259
      },
      "writtenOn": "2024-01-15T08:46:38Z",
      "side": 1,
      "message": "did you look for direct access to this public member that would need to be replaced by getAudioTrack()?",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 41,
        "endChar": 31
      },
      "revId": "7e85873d407557627ee9a10f3421f6fd4302073e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0b7f9f77_bce137fe",
        "filename": "media/libaudioclient/include/media/TrackPlayerBase.h",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 1042638
      },
      "writtenOn": "2024-01-16T17:30:46Z",
      "side": 1,
      "message": "I think, a more practical solution is to replace this `sp` with an `atomic_sp`: https://cs.android.com/android/platform/superproject/main/+/main:frameworks/av/media/utils/include/mediautils/Synchronization.h;l\u003d115;drc\u003d24d1a985cba70eca151ab07d6fef76ff1ca4f483",
      "parentUuid": "78e7f882_dfae6c6c",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 41,
        "endChar": 31
      },
      "revId": "7e85873d407557627ee9a10f3421f6fd4302073e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ac74bcd1_eb765c42",
        "filename": "media/libaudioclient/include/media/TrackPlayerBase.h",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 1494236
      },
      "writtenOn": "2024-01-16T17:38:43Z",
      "side": 1,
      "message": "I actually don\u0027t think making this thread-safe is necessary, since if we call destroy while the object is live in a concurrent context, there is no well-formed way to make it safe.\n\nBasically, I think it\u0027s better to make the non-nullity of the sp an invariant of an inited trackplayer. This probably requires a minor change in how we call from SLES, though.",
      "parentUuid": "0b7f9f77_bce137fe",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 41,
        "endChar": 31
      },
      "revId": "7e85873d407557627ee9a10f3421f6fd4302073e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "89ec91fc_544c777e",
        "filename": "media/libaudioclient/include/media/TrackPlayerBase.h",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 2005646
      },
      "writtenOn": "2024-01-16T18:27:44Z",
      "side": 1,
      "message": "To provide some more context: we\u0027re seeing occasional crashes (null pointer dereferences) in the wild in AudioTrack\u0027s `applyVolumeShaper` [here](https://android.googlesource.com/platform/frameworks/av/+/0d238df741687e4205546a0b682e5d69e0514f40/media/libaudioclient/AudioTrack.cpp#3055), called from [TrackPlayerBase](https://android.googlesource.com/platform/frameworks/av/+/0d238df741687e4205546a0b682e5d69e0514f40/media/libaudioclient/TrackPlayerBase.cpp#146), because the `AudioTrack` had already been destructed (so its `sp\u003cmedia::IAudioTrack\u003e` is null).\n\nMy main goal was to prevent such crashes by making existing null checks in `TrackPlayerBase` resilient to races (e.g. a race between `applyVolumeShaper` calling a method via the `sp\u003c\u003e` and `doDestroy()` dropping the last reference). \n\nThis CL ensures that the underlying `AudioTrack` object still exists, but doesn\u0027t guarantee that it\u0027s in a valid state. For example, the following is possible:\n\n1. Thread 1 calls `getAudioTrack()` and gets a valid reference to the `AudioTrack` object.\n2. Thread 2 calls `destroy()` which calls `stop()` on the same AudioTrack object\n3. Thread 1 now calls some other method on that object, which either races with `stop()` or doesn\u0027t expect the `AudioTrack` to be in the stopped state.\n\n\nGiven there\u0027s locking internally in `AudioTrack` I assumed this is fine, i.e. at worst it\u0027ll result in an error being returned and/or logged, but won\u0027t crash. That said:\n\n\u003e to make the non-nullity of the sp an invariant of an inited trackplayer\n\nThis does seem cleaner. What kind of changes would that require exactly?",
      "parentUuid": "ac74bcd1_eb765c42",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 41,
        "endChar": 31
      },
      "revId": "7e85873d407557627ee9a10f3421f6fd4302073e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1403254a_b97cf7de",
        "filename": "media/libaudioclient/include/media/TrackPlayerBase.h",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 1494236
      },
      "writtenOn": "2024-01-16T18:55:37Z",
      "side": 1,
      "message": "\u003e This does seem cleaner. What kind of changes would that require exactly?\n\nThe only callee of destroy directly is OpenSLES.\n\nAs long as moving up the pointer clear [here](https://cs.android.com/android/platform/superproject/main/+/dd7a7ea69100ba31545b399f40f8480b07a1b508:frameworks/wilhelm/src/android/AudioPlayer_to_android.cpp;drc\u003d53ac8c773c6601a8d4e98db50dad3c390f717f7c;l\u003d1943) is valid (see after the switch statement), it should work (we are deferring handling concurrency on methods a layer up).\n\nThis is the only place I think we should have this race (but it seems very hard to hit, so I wonder if there is an issue anywhere else), since (if we call the method from sp\u003c\u003e), we can never call the dtor while holding the object to call another method. \n\nAs mentioned, we also need to check the write references since the member is public.",
      "parentUuid": "89ec91fc_544c777e",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 41,
        "endChar": 31
      },
      "revId": "7e85873d407557627ee9a10f3421f6fd4302073e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7bd918ec_ed3df34b",
        "filename": "media/libaudioclient/include/media/TrackPlayerBase.h",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 2005646
      },
      "writtenOn": "2024-01-17T01:14:37Z",
      "side": 1,
      "message": "\u003e since (if we call the method from sp\u003c\u003e), we can never call the dtor while holding the object to call another method.\n\nWe\u0027re calling methods directly on `mAudioTrack`, for example in `applyVolumeShaper` [here](https://android.googlesource.com/platform/frameworks/av/+/0d238df741687e4205546a0b682e5d69e0514f40/media/libaudioclient/TrackPlayerBase.cpp#146). That just deferences the underlying `m_ptr` (doesn\u0027t increase the refcount), so it can still race with `~sp()` dropping the last reference and destructing the object AFAICT.\n\n\u003e we are deferring handling concurrency on methods a layer up\n\nHm, would you mind clarifying this part? Is there a mechanism in place that prevents `doDestroy` (called via OpenSLES on an application thread) from racing with `applyVolumeShaper` (called by AudioFlinger, running on one of the binder threads)?",
      "parentUuid": "1403254a_b97cf7de",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 41,
        "endChar": 31
      },
      "revId": "7e85873d407557627ee9a10f3421f6fd4302073e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5a3dfceb_1429ce91",
        "filename": "media/libaudioclient/include/media/TrackPlayerBase.h",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 2005646
      },
      "writtenOn": "2024-01-17T01:28:33Z",
      "side": 1,
      "message": "\u003e did you look for direct access to this public member that would need to be replaced by getAudioTrack()?\n\nGood point. I see this same pattern in a few places in frameworks/wilhelm:\n\n```\nif (ap-\u003emTrackPlayer-\u003emAudioTrack !\u003d 0) {\n    // do something with mAudioTrack\n}\n```\n\nI can change that to `getAudioTrack()` in a follow-up CL if we decide to go forward with this approach.",
      "parentUuid": "7bd918ec_ed3df34b",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 41,
        "endChar": 31
      },
      "revId": "7e85873d407557627ee9a10f3421f6fd4302073e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "573959ea_2770b40a",
        "filename": "media/libaudioclient/include/media/TrackPlayerBase.h",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 1494236
      },
      "writtenOn": "2024-01-17T04:05:27Z",
      "side": 1,
      "message": "\u003e We\u0027re calling methods directly on mAudioTrack, for example in applyVolumeShaper here.\n\nIf a method on a class is called concurrently with the destructor, then all bets are off.\n\nSo, if we only ~sp in the dtor of this class AND we don\u0027t leak the raw ptr of the sp outside the class, then we don\u0027t have a concurrent call.\n\n\u003e Hm, would you mind clarifying this part?\n\nThe guarantee doesn\u0027t exist for the code as-is, because we call destroy explicitly from SLES. If we didn\u0027t it would apply:\n\nThe implicit guarantee is from sp\u003cTrackBase\u003e -\u003e if we are being called from af, then the object is still alive -\u003e the track is still alive. I need to double check on circular refs, though.",
      "parentUuid": "5a3dfceb_1429ce91",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 41,
        "endChar": 31
      },
      "revId": "7e85873d407557627ee9a10f3421f6fd4302073e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0b623eea_4ceeecd9",
        "filename": "media/libaudioclient/include/media/TrackPlayerBase.h",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 2005646
      },
      "writtenOn": "2024-01-17T23:24:44Z",
      "side": 1,
      "message": "@atneya@google.com: I see what you mean, thanks! Yeah, without that `destroy()` we wouldn\u0027t have the race since the `AudioTrack` would be guaranteed to be valid.\n\nIf we were to skip calling `TrackPlayerBase::destroy()` altogether, I suspect that might introduce another issue in OpenSLES clients that call Destroy _without_ previously changing the playstate to STOPPED. In that case AudioFlinger would prevent the object from being released properly (by holding a reference to it via the `IPlayer` binder proxy), right?\n\nI wonder if simply modifying `doDestroy()` to not call `mAudioTrack.clear()` would be sufficient here -- if so, that would be a much simpler fix. Let me give that a try.",
      "parentUuid": "573959ea_2770b40a",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 41,
        "endChar": 31
      },
      "revId": "7e85873d407557627ee9a10f3421f6fd4302073e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ede90207_c1e74a27",
        "filename": "media/libaudioclient/include/media/TrackPlayerBase.h",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 2005646
      },
      "writtenOn": "2024-01-23T22:19:07Z",
      "side": 1,
      "message": "\u003e I wonder if simply modifying doDestroy() to not call mAudioTrack.clear() would be sufficient here\n\nI tried this out, but there\u0027s another subtle issue (not directly related to this code) that probably makes it a non-starter.\n\nJust to clarify a bit further, the original crash we observed is due to a race between the following:\n\n- Application calling Destroy on the OpenSL player object, which ends up invoking TrackPlayerBase::doDestroy\n- PlaybackActivityMonitor (part of AudioService, in system_server) calling applyVolumeShaper[*]\n\nIf we maintained the invariant that mAudioTrack of an init()-ed TrackPlayerBase is non-null (thus deferring the destruction of AudioTrack until ~TrackPlayerBase), we\u0027d potentially be keeping these objects alive for _much longer than needed_.\n\nTrackPlayerBase (which implements the IPlayer interface) is sent to AudioService via [trackPlayer](https://cs.android.com/android/platform/superproject/main/+/main:frameworks/av/media/libaudioclient/PlayerBase.cpp;drc\u003d419312541747dc19d37c23f8e65fdf0650f7c83e;l\u003d56), which in turn forwards it to other processes that implement the AudioPlaybackCallback interface, e.g. `com.android.bluetooth` [here](https://cs.android.com/android/platform/superproject/main/+/main:packages/modules/Bluetooth/android/app/src/com/android/bluetooth/audio_util/MediaPlayerList.java;drc\u003d5b001d8d980f2c64fd748ad7a06fcda0d59f4f47;l\u003d831). Binder proxy objects in other processes keep the TrackPlayerBase refcount non-zero, so we\u0027re effectively at the mercy of the garbage collector. I suspect this may be why `doDestroy()` was originally implemented this way (to clear `mAudioTrack`).\n\nI tested this with an app that uses OpenSLES to create and then destroy multiple audio player objects. Binder debugfs entries showed that the bluetooth process still had references to `IPlayer` binder nodes created by the app, and it was only after I explicitly triggered GC (by sending SIGUSR1 to com.android.bluetooth) that TrackPlayerBase destructors were called.\n\nConsidering the complication with binder proxies, I think we\u0027d still want to explicitly tear down `mAudioTrack` in `TrackPlayerBase::doDestroy` (which makes the race described above possible). This CL is one way of fixing it, but I wonder what you all think? cc @atneya@google.com\n\n[*] IPlayer.applyVolumeShaper() is a one-way binder call, so we could get it even after the OpenSL Destroy call, which unregisters the IPlayer with PlaybackActivityMonitor, returns.",
      "parentUuid": "0b623eea_4ceeecd9",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 41,
        "endChar": 31
      },
      "revId": "7e85873d407557627ee9a10f3421f6fd4302073e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}
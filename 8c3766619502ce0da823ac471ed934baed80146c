{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1a285d1a_778bd3ee",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1392607
      },
      "writtenOn": "2023-12-11T21:39:24Z",
      "side": 1,
      "message": "Hi @lajos@google.com, @wonsik@google.com, could you help to review this change? Thank you!",
      "revId": "8c3766619502ce0da823ac471ed934baed80146c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4bc0393e_a7a8276f",
        "filename": "media/codec2/core/include/C2Config.h",
        "patchSetId": 7
      },
      "lineNbr": 1969,
      "author": {
        "id": 1021605
      },
      "writtenOn": "2023-12-12T01:00:09Z",
      "side": 1,
      "message": "Will the component handle the rectangle config, or will the HAL layer convert it into a QP MAP, and component only handles the map version?",
      "range": {
        "startLine": 1969,
        "startChar": 4,
        "endLine": 1969,
        "endChar": 22
      },
      "revId": "8c3766619502ce0da823ac471ed934baed80146c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "edbd6005_1924ebf5",
        "filename": "media/codec2/core/include/C2Config.h",
        "patchSetId": 7
      },
      "lineNbr": 1969,
      "author": {
        "id": 1392607
      },
      "writtenOn": "2023-12-12T01:31:18Z",
      "side": 1,
      "message": "We prefer the component handles both rectangle and QP maps types.",
      "parentUuid": "4bc0393e_a7a8276f",
      "range": {
        "startLine": 1969,
        "startChar": 4,
        "endLine": 1969,
        "endChar": 22
      },
      "revId": "8c3766619502ce0da823ac471ed934baed80146c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ff429dce_bcc22c64",
        "filename": "media/codec2/core/include/C2Config.h",
        "patchSetId": 7
      },
      "lineNbr": 1969,
      "author": {
        "id": 1150374
      },
      "writtenOn": "2024-01-22T15:44:22Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "edbd6005_1924ebf5",
      "range": {
        "startLine": 1969,
        "startChar": 4,
        "endLine": 1969,
        "endChar": 22
      },
      "revId": "8c3766619502ce0da823ac471ed934baed80146c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5917e099_91a16b6f",
        "filename": "media/codec2/core/include/C2Config.h",
        "patchSetId": 7
      },
      "lineNbr": 1973,
      "author": {
        "id": 1021605
      },
      "writtenOn": "2023-12-12T01:00:09Z",
      "side": 1,
      "message": "is the expectation that this can change at run-time?",
      "revId": "8c3766619502ce0da823ac471ed934baed80146c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "508163c9_61146d6f",
        "filename": "media/codec2/core/include/C2Config.h",
        "patchSetId": 7
      },
      "lineNbr": 1973,
      "author": {
        "id": 1392607
      },
      "writtenOn": "2023-12-12T01:31:18Z",
      "side": 1,
      "message": "No. This key should be configured before `encoder.run()` is called. At run-time, Java layer should check if the configuration for each frame matches the ROI_type, if not raise an exception.",
      "parentUuid": "5917e099_91a16b6f",
      "revId": "8c3766619502ce0da823ac471ed934baed80146c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "22d15c32_2019178d",
        "filename": "media/codec2/core/include/C2Config.h",
        "patchSetId": 7
      },
      "lineNbr": 1973,
      "author": {
        "id": 1392607
      },
      "writtenOn": "2024-01-17T06:31:04Z",
      "side": 1,
      "message": "Related comments above. If we remove `roi_type_t` parameter, this will also need to be changed.",
      "parentUuid": "508163c9_61146d6f",
      "revId": "8c3766619502ce0da823ac471ed934baed80146c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "44a6637c_939b6007",
        "filename": "media/codec2/core/include/C2Config.h",
        "patchSetId": 7
      },
      "lineNbr": 1973,
      "author": {
        "id": 1150374
      },
      "writtenOn": "2024-01-22T15:44:22Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "22d15c32_2019178d",
      "revId": "8c3766619502ce0da823ac471ed934baed80146c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "14be8242_b877b5a6",
        "filename": "media/codec2/core/include/C2Config.h",
        "patchSetId": 7
      },
      "lineNbr": 1984,
      "author": {
        "id": 1021605
      },
      "writtenOn": "2023-12-12T01:00:09Z",
      "side": 1,
      "message": "Few questions\n\n1) Are these configs sticky, or does it have to be specified for each frame. E.g. sticky means that if unspecified, the last value should be used, whereas non-sticky means, if unspecified for a frame, the QP offsets should be zero.\n\n2) Do you support float offsets? x264 seems to support that.\n\n3) Do these represent QP offset for I LCUs only? Is there some arithmetic to be applied when LCU is coded as P or B (similarly to how QP bounds are specified separately for I, P and B?",
      "range": {
        "startLine": 1984,
        "startChar": 30,
        "endLine": 1984,
        "endChar": 41
      },
      "revId": "8c3766619502ce0da823ac471ed934baed80146c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "09e8bb9c_6aee190e",
        "filename": "media/codec2/core/include/C2Config.h",
        "patchSetId": 7
      },
      "lineNbr": 1984,
      "author": {
        "id": 1392607
      },
      "writtenOn": "2023-12-12T01:31:18Z",
      "side": 1,
      "message": "1) non sticky\n2) no\n3) no",
      "parentUuid": "14be8242_b877b5a6",
      "range": {
        "startLine": 1984,
        "startChar": 30,
        "endLine": 1984,
        "endChar": 41
      },
      "revId": "8c3766619502ce0da823ac471ed934baed80146c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a5acffd2_aef0cc10",
        "filename": "media/codec2/core/include/C2Config.h",
        "patchSetId": 7
      },
      "lineNbr": 1984,
      "author": {
        "id": 1021605
      },
      "writtenOn": "2024-01-12T23:10:04Z",
      "side": 1,
      "message": "1) C2 configs as this are generally sticky, so if this is not sticky, there needs to be a justification for why not. E.g. what is the expected cost of having the client specify this for each frame and will apps specify this explicitly for each frame. This config as it stands is marshaled across binder for each frame, so that would not work for a non-sticky config.\n\nAn option would be to use an InfoBuffer with PixelFormatY8 - though MediaCodec.java does not currently support InfoBuffers.\n\n2) This was really a question on why this is not a float since x264 (e.g.) has this as a float. (e.g. we would not be able to support all x264 configurations with this being an integer.) The consensus is that having this as a float increases bandwidth requirements 4x, and also QP being an integer, this may cause confusion for clients. E.g. on most implementations a +0.2 QP would get ignored, and this is not what apps would expect if this was a float.\n\n3) This was another question on why have a single value, instead of having separate value for each macroblock types. We discussed this in detail, and the conclusion is that when QP bounds are specified, the P and B QPs are derived from the I QP using an offset",
      "parentUuid": "09e8bb9c_6aee190e",
      "range": {
        "startLine": 1984,
        "startChar": 30,
        "endLine": 1984,
        "endChar": 41
      },
      "revId": "8c3766619502ce0da823ac471ed934baed80146c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f9cb21d9_f87ffbc6",
        "filename": "media/codec2/core/include/C2Config.h",
        "patchSetId": 7
      },
      "lineNbr": 1984,
      "author": {
        "id": 1392607
      },
      "writtenOn": "2024-01-17T06:31:04Z",
      "side": 1,
      "message": "Hi Lajos,\n\nWe had some internal discussion within our team, and here are our conclusions:\n\n1) Sticky/non-sticky: from users\u0027 point of view a non-sticky model is preferred. Because user calculate/configure ROI for one specific frame; if there is no ROI configured, that means no ROI is detected, and it is preferred that the encoder automatically uses zero ROI configuration instead of user manually pass a zero ROI configuration into the encoder.\n\nRegarding the size, since the QP map size is 1 byte every 16x16 block, and it\u0027s about 0.26% of the size of one frame in YUV_420, we think this is acceptable.\n\n2) Float QP offsets: we would prefer not to have it.\n\n3) Separate QP offsets for each I/P/B type: we still want to use 1 value to represent ROI QP offset, and we think this is enough / we don\u0027t see benefit by setting I/P/B QPs separately. This offset should be applied after all the QP calculation complete by the encoder. E.g. encoder rate control and QP bounding calculations give QP for I macroblock equals to A, QP for P macroblock equals to B, ROI QP offset is X, then the final QP for both macroblocks should be (A - X), (B - X) sequentially.",
      "parentUuid": "a5acffd2_aef0cc10",
      "range": {
        "startLine": 1984,
        "startChar": 30,
        "endLine": 1984,
        "endChar": 41
      },
      "revId": "8c3766619502ce0da823ac471ed934baed80146c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "29f133e8_fdeb4d91",
        "filename": "media/codec2/core/include/C2Config.h",
        "patchSetId": 7
      },
      "lineNbr": 1984,
      "author": {
        "id": 1392607
      },
      "writtenOn": "2024-01-17T06:42:36Z",
      "side": 1,
      "message": "Out of curious, if we keep using non-sticky design, the \"non-sticky\" part should be handled by SoCs or C2? Thanks!",
      "parentUuid": "f9cb21d9_f87ffbc6",
      "range": {
        "startLine": 1984,
        "startChar": 30,
        "endLine": 1984,
        "endChar": 41
      },
      "revId": "8c3766619502ce0da823ac471ed934baed80146c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a6081ba6_afacbd4e",
        "filename": "media/codec2/core/include/C2Config.h",
        "patchSetId": 7
      },
      "lineNbr": 1984,
      "author": {
        "id": 1392607
      },
      "writtenOn": "2024-01-24T23:49:24Z",
      "side": 1,
      "message": "Conclusion: C2 layer will be sticky and JAVA API layer will be non-sticky. Framework will need to handle this.",
      "parentUuid": "29f133e8_fdeb4d91",
      "range": {
        "startLine": 1984,
        "startChar": 30,
        "endLine": 1984,
        "endChar": 41
      },
      "revId": "8c3766619502ce0da823ac471ed934baed80146c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "43fdf4fd_dcbdc333",
        "filename": "media/codec2/core/include/C2Config.h",
        "patchSetId": 7
      },
      "lineNbr": 1989,
      "author": {
        "id": 1021605
      },
      "writtenOn": "2023-12-12T01:00:09Z",
      "side": 1,
      "message": "Do we need to create a rectangular configuration option? The handling of this is underspecified, so it may lead to device specific behaviors. E.g. what happens if the coordinates are in the middle of macroblocks/LCUs? What happens if the coordinates are overlapped (are these additive, last one wins, first one wins?).",
      "range": {
        "startLine": 1989,
        "startChar": 3,
        "endLine": 1989,
        "endChar": 65
      },
      "revId": "8c3766619502ce0da823ac471ed934baed80146c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "87b80fe1_7a35dfd0",
        "filename": "media/codec2/core/include/C2Config.h",
        "patchSetId": 7
      },
      "lineNbr": 1989,
      "author": {
        "id": 1392607
      },
      "writtenOn": "2023-12-12T01:31:18Z",
      "side": 1,
      "message": "We expect to have both QP_map and rectangle types. We have defined the behaviors of those cases:\n\n1) If coordinates are in the middle of a LCU QP offset will be extended to the nearest LCUs.\n2) When coordinates overlap, the last one wins.",
      "parentUuid": "43fdf4fd_dcbdc333",
      "range": {
        "startLine": 1989,
        "startChar": 3,
        "endLine": 1989,
        "endChar": 65
      },
      "revId": "8c3766619502ce0da823ac471ed934baed80146c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e0867eb9_c64bd4a0",
        "filename": "media/codec2/core/include/C2Config.h",
        "patchSetId": 7
      },
      "lineNbr": 1989,
      "author": {
        "id": 1150374
      },
      "writtenOn": "2024-01-22T15:44:22Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "87b80fe1_7a35dfd0",
      "range": {
        "startLine": 1989,
        "startChar": 3,
        "endLine": 1989,
        "endChar": 65
      },
      "revId": "8c3766619502ce0da823ac471ed934baed80146c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}